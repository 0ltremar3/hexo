<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo博客乱码问题解决]]></title>
    <url>%2F2019%2F07%2F31%2Fhexo%E5%8D%9A%E5%AE%A2%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[将博客文件保存为UTF-8即可解决问题。 方法： ​ 1.将博客文件保存为UTF-8 ​ 用记事本打开本地的博客文件“xxx.md”，然后点“另存为”，“编码(E):”选择“UTF-8”， ​ 点击“保存”，替换原文件。 ​ 2.重新生成，部署，博客乱码即消除。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1025. PAT Ranking (25)]]></title>
    <url>%2F2018%2F08%2F29%2F1025.%20PAT%20Ranking%20(25)%2F</url>
    <content type="text"><![CDATA[Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank. Input Specification:Each input file contains one test case. For each case, the first line contains a positive number N (&lt;=100), the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer K (&lt;=300), the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space. Output Specification:For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:registration_number final_rank location_number local_rankThe locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers. Sample Input:123456789101112251234567890001 951234567890005 1001234567890003 951234567890002 771234567890004 8541234567890013 651234567890011 251234567890014 1001234567890012 85 Sample Output:1234567891091234567890005 1 1 11234567890014 1 2 11234567890001 3 1 21234567890003 3 1 21234567890004 5 1 41234567890012 5 2 21234567890002 7 1 51234567890013 8 2 31234567890011 9 2 4 代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;/* run this program using the console pauser or add your own getch, system("pause") or input loop */struct student&#123; char id[13];//int 范围 [-2147483648, 2147483647] int grade; int loc_rank; int loc;&#125;stu[1000];bool cmp(student a,student b)&#123; if(a.grade!=b.grade)&#123; return a.grade&gt;b.grade; &#125; else return strcmp(a.id,b.id)&lt;0;&#125;int main(int argc, char** argv) &#123; int locn;//考场数量 int k,num=0;//k为当前考场内学生数量，num为学生总数 scanf("%d",&amp;locn); /*处理输入*/ for(int i=1;i&lt;=locn;i++)&#123; scanf("%d",&amp;k); for(int j=0;j&lt;k;j++)&#123;//当前考场学生信息录入 scanf("%s%d",stu[num].id,&amp;stu[num].grade);// stu[num].loc=i; num++; &#125; /*当前考场排序与排名处理*/ sort(stu+num-k,stu+num,cmp);//当前考场排序 stu[num-k].loc_rank=1; for(int j=num-k+1;j&lt;num;j++)&#123; if(stu[j].grade==stu[j-1].grade)&#123; stu[j].loc_rank=stu[j-1].loc_rank; &#125; else stu[j].loc_rank=j+1-(num-k);//!!!成绩不相等时，排名=当前考生数组下标+1（真实人数）-起始位置 &#125; &#125; /*总排名*/ printf("%d\n",num); sort(stu,stu+num,cmp); int r=1; for(int j=0;j&lt;num;j++)&#123; if(j&gt;0&amp;&amp;stu[j].grade!=stu[j-1].grade)&#123;//stu[j].grade!=stu[j+1].grade r=j+1;//!!! &#125; printf("%s %d %d %d\n",stu[j].id,r,stu[j].loc,stu[j].loc_rank);//准考证号 总排名 考场号 本地排名 &#125; return 0;&#125; 来源：https://www.patest.cn/contests/pat-a-practise/1025]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT(A)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1928.日期差值]]></title>
    <url>%2F2018%2F08%2F29%2F1928.%E6%97%A5%E6%9C%9F%E5%B7%AE%E5%80%BC%2F</url>
    <content type="text"><![CDATA[有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天。 输入 有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD 输出 每组数据输出一行，即日期差值 样例输入 122013010120130105 样例输出 15 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* run this program using the console pauser or add your own getch, system("pause") or input loop *//*闰年(四年一闰，百年不闰，四百年再闰）366天，平年365天；13578 10 12为31天，其余30天。难点：日-月-年的跳转*/int isrunnian(int y)&#123; if((y%4==0&amp;&amp;y%100!=0)||(y%400==0))&#123; return 1; &#125; else return 0;&#125;int month[13][2]=&#123;&#123;0,0&#125;,&#123;31,31&#125;,&#123;28,29&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;,&#123;30,30&#125;,&#123;31,31&#125;&#125;;//13是为了月份下标从1开始 .[][0]是平年，[][1]闰年（bool函数铺垫）int main(int argc, char *argv[]) &#123; /*处理日期输入*/ int date1,date2;//（程序内部）规定date1小于date2 int y1,y2,m1,m2,d1,d2; while(scanf("%d%d",&amp;date1,&amp;date2)!=EOF)&#123; y1=date1/10000;m1=date1/100%100;d1=date1%100;//取一个X位整数i的前N位： i/10^（X-N）;后M位：i%10^M; y2=date2/10000;m2=date2/100%100;d2=date2%100; if(date1&gt;date2) &#123;//如果输反则交换 int temp=date1; date1=date2; date2=temp; &#125; /*计算日期差值*/ int cnt=1;// 题设：如果两个日期是连续的，则规定他们之间的天数为2天 while(y1&lt;y2||m1&lt;m2||d1&lt;d2)&#123;//为什么while(date1&lt;date2)不行？——因为这个循环根本没有改变date们的值！逻辑上只和ymd相关，和date半毛钱关系都没 d1++; if(d1&gt;month[m1][isrunnian(y1)])&#123;//这里超厉害 m1++; d1=1;//注意重置day &#125; if(m1&gt;12)&#123; y1++; m1=1;//注意重置month &#125; cnt++; &#125; printf("%d\n",cnt); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>codeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1042. Shuffling Machine (20)]]></title>
    <url>%2F2018%2F08%2F29%2F1042.%20Shuffling%20Machine%20(20)%2F</url>
    <content type="text"><![CDATA[Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine. The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:S1, S2, …, S13, H1, H2, …, H13, C1, C2, …, C13, D1, D2, …, D13, J1, J2where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer K (&lt;= 20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space. Output Specification:For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line. Sample Input:12236 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47 Sample Output: 1S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5 分析：简单模拟。使用start和end数组保存每一次变换的开始顺序和结束顺序（以1~54的编号存储），最后根据编号与扑克牌字母数字的对应关系输出end数组。开char数组c[5]={‘S’,’H’,’C’,’D’,’J’}(和开c[6]={“SHCDJ”}效果相同),需特别注意与花色对应的编号-1问题：13/13=1，小于13的数除以13结果才为0. 题解：123456789101112131415161718192021222324#include &lt;cstdio&gt;using namespace std;int main() &#123; int cnt; scanf("%d", &amp;cnt); int start[55], end[55], scan[55]; for(int i = 1; i &lt; 55; i++) &#123; scanf("%d", &amp;scan[i]); end[i] = i; &#125; for(int i = 0; i &lt; cnt; i++) &#123; for(int j = 1; j &lt; 55; j++) start[j] = end[j]; for(int k = 1; k &lt; 55; k++) end[scan[k]] = start[k]; &#125; char c[6] = &#123;"SHCDJ"&#125;;//末尾为‘/0’，故长度为6 for(int i = 1; i &lt; 55; i++) &#123; end[i] = end[i] - 1; printf("%c%d", c[end[i]/13], end[i]%13+1); if(i != 54) printf(" "); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT(A)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1065. A+B and C (64bit) (20)]]></title>
    <url>%2F2018%2F08%2F28%2F1065.%20A%2BB%20and%20C%20(64bit)%20(20)%2F</url>
    <content type="text"><![CDATA[Given three integers A, B and C in [-263, 263], you are supposed to tell whether A+B &gt; C. Input Specification:The first line of the input gives the positive number of test cases, T (&lt;=10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces. Output Specification:For each test case, output in one line “Case #X: true” if A+B&gt;C, or “Case #X: false” otherwise, where X is the case number (starting from 1).” Sample Input:123431 2 32 3 49223372036854775807 -9223372036854775808 0 Sample Output:123Case #1: falseCase #2: trueCase #3: false 分析：因为A、B的大小为[-2^63, 2^63]，用long long 存储A和B的值，以及他们相加的值sum： 如果A &gt; 0, B &lt; 0 或者 A &lt; 0, B &gt; 0，sum是不可能溢出的如果A &gt; 0, B &gt; 0，sum可能会溢出，sum范围理应为(0, 2^64 – 2]，溢出得到的结果应该是[-2^63, -2]是个负数，所以sum &lt; 0时候说明溢出了如果A &lt; 0, B &lt; 0，sum可能会溢出，同理，sum溢出后结果是大于0的，所以sum &gt; 0 说明溢出了上溢:数值太大，超过该类型的最大表数范围;下溢:数值过小，小于该类型的最小表数范围。c是在题目给定范围中的，类型选对肯定不会超出。但a，b同号时a+b就可能超出表数范围，所以过大(肯定大于c)时true，过小时false. 题解（别人的）：123456789101112131415161718192021#include &lt;cstdio&gt;using namespace std;int main() &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; long long a, b, c; scanf("%lld %lld %lld", &amp;a, &amp;b, &amp;c); long long sum = a + b; if(a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; sum &lt; 0) &#123; printf("Case #%d: true\n", i + 1); &#125; else if(a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; sum &gt;= 0)&#123; printf("Case #%d: false\n", i + 1); &#125; else if(sum &gt; c) &#123; printf("Case #%d: true\n", i + 1); &#125; else &#123; printf("Case #%d: false\n", i + 1); &#125; &#125; return 0;&#125; 自己的题解1（部分正确，想不通哪儿错了）：12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;bool cmp(int a,int b,int c)&#123; long long sum=a+b; if(a&gt;0&amp;&amp;b&gt;0&amp;&amp;sum&lt;0)&#123; return true; &#125; else if(a&lt;0&amp;&amp;b&lt;0&amp;&amp;sum&gt;=0)&#123; return false; &#125; else &#123; return sum&gt;c?true:false; &#125;&#125;int main()&#123; long long a,b,c; int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(cmp(a,b,c)) &#123; printf("Case #%d: true\n", i); &#125; else if(!cmp(a,b,c))&#123; printf("Case #%d: false\n", i); &#125; &#125; return 0;&#125; 自己的题解2(已AC)：1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; long long a,b,c,sum; int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++)&#123; bool flag=false;//注意flag位置 scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c); sum=a+b; if(a&gt;0&amp;&amp;b&gt;0&amp;&amp;sum&lt;=0)&#123; flag=true; &#125; else if(a&lt;0&amp;&amp;b&lt;0&amp;&amp;sum&gt;=0)&#123; flag=false; &#125; else if(sum&gt;c)&#123; flag=true; &#125; if(flag==true) printf("Case #%d: true\n",i); else if(flag==false) printf("Case #%d: false\n",i); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT(A)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1046. Shortest Distance (20)]]></title>
    <url>%2F2018%2F08%2F27%2F1046.%20Shortest%20Distance%20(20)%2F</url>
    <content type="text"><![CDATA[The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits. Input Specification:Each input file contains one test case. For each case, the first line contains an integer N (in [3,105]), followed by N integer distances D1 D2 ⋯ DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (≤104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107. Output Specification:For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits. Sample Input: 123455 1 2 4 14 931 32 54 1 Sample Output:1233107 分析：只有两条路可走，路2长度=总路长-路1长。比较两个路长即可得答案。eg.v2-&gt;v4路长求法：L( v1-&gt;v4 )-L(v1-&gt;v2)，故用dis[i]存v1到vi的距离。注意：初始化dis[1]=0；vn-&gt;v1的路长存在dis[n+1]里，但实际用不到dis[n+1]。 题解：123456789101112131415161718192021222324252627282930313233343536373839/** @Author: Jerry* @Date: 2018-08-25 14:44:36* @Last Modified by: Jerry* @Last Modified time: 2018-08-25 14:57:41*/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int min(int a,int b)&#123; return a&lt;b?a:b;&#125;int main()&#123; int n; cin &gt;&gt; n; int total,tmp; total=0; vector&lt;int&gt; dis(n+2);//必须指定大小，不然出错；且大小是n+2 dis[1]=0; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; tmp; total+=tmp; dis[i+1]=dis[i]+tmp; &#125; int m,t; cin &gt;&gt; m; int left,right,result; while(m--)&#123; cin &gt;&gt; left &gt;&gt; right; t=abs(dis[left]-dis[right]); result=min(t,total-t); cout &lt;&lt; result &lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT(A)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基本用法]]></title>
    <url>%2F2018%2F08%2F26%2FC%2B%2B%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] 头文件12#include &lt;iostream&gt;using namespace std; 输入输出cin 可同时输入多个变量 1cin &gt;&gt; n &gt;&gt; db &gt;&gt; c &gt;&gt; str; 输入一整行数组要用getline 123456//字符型数组char str[10];cin.getline(str,100);//string容器string str;getline(cin,str); cin的结束标志: 读入空格和回车； while(cin &gt;&gt; x)时，ctrl+z退出循环。 cout 可同时输出多个变量 1cout &lt;&lt; n &lt;&lt; db &lt;&lt; c &lt;&lt; str; 加空格、字符用” “ 1cout &lt;&lt; n &lt;&lt; " " &lt;&lt; db; 换行用”\n”或endl 1cout &lt;&lt; n &lt;&lt; "\n" &lt;&lt; db &lt;&lt; endl; 注意事项考试除非必要(如使用string时)，不建议用cin和cout，耗时过长，性能比较差。 STLvector定义 头文件 12#include &lt;vector&gt;using namespace std; 功能类似变长数组,大小随输入变化。 声明 1234vector &lt;typeName&gt; name;//具体例子vector &lt;int&gt; vi;vector &lt;int&gt; vi(100);//指定vi大小为100 类似二维数组的形式vector &lt;vector&lt;typeName&gt; &gt; name;//注意&gt; &gt;之间需要加空格，否则会是别的含意 vector数组vector &lt;int&gt; vi[100];//vi[0]~vi[99]每一个都是vector容器元素访问1.下标访问vi[index];2.迭代器访问12345vector &lt;typeName&gt;::iterator it;it = vi.begin();//取首元素地址，访问vi[0]it = vi.begin + 3;//访问vi[3]for(it = vi.begin();it != vi.end();it++)//遍历&#123;···&#125; 常用函数 size(); 12vector &lt;int&gt; vi;cout &lt;&lt; vi.size();//获得vi的大小 string定义 头文件12#include &lt;string&gt;using namespace std; 元素访问 下标访问像访问字符数组一样。 迭代器访问string::iterator it; 如果要输入/输出整个字符串，只能用cin和cout.常用函数 compare operator直接用&gt;,=,&lt;来按字典序比较字符串。 perator+=字符串直接相加减 set定义 头文件 12#include &lt;set&gt;using namespace std; 功能set（集合），是一个内部自动有序且不含重复元素的容器。 声明set&lt;typename&gt; name;元素访问只能通过迭代器(iterator)访问： 123456789101112set&lt;typename&gt;::iterator it;`只能按如下方式枚举：​```cppset&lt;int&gt; st;st.insert(5);st.insert(1);st.insert(3);for(set&lt;int&gt;::iterator it=st.begin();it!=st.end();it++)&#123; printf("%d",*it);&#125; 输出结果： 1 3 5 常用函数 insert() find() erase() size() clear() map定义-头文件12#include &lt;map&gt;using namespace std; 声明map&lt;typename1,typename2&gt; name;//1为键，2为值 功能下标和对应值的类型可以不同，如map[‘a’]=1。元素访问 下标map[&#39;c&#39;]=3; 迭代器it-&gt;first访问下标,it-&gt;second访问值。常用函数]]></content>
      <tags>
        <tag>语言</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F08%2F25%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] 冒泡排序思想:排n-1趟，每趟都从第一个元素开始和后一个比较，把最大的放在最后。如果已排好序，代表不会进入比较大小的if语句，直接退出循环。 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#define NUM 6void BubbleSort(int arr[],int n)&#123; int i,j,tmp,flag; for(i = 1;i &lt; n;i++)&#123; flag = 0; for(j = 0;j &lt; n - i;j++)&#123; if(arr[j] &gt; arr[j+1])&#123; tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; flag = 1; &#125; &#125; if(!flag) break; &#125;&#125;int main()&#123; int arr[NUM] = &#123;7,3,2,6,4,1&#125;; BubbleSort(arr,NUM); int i; for (i = 0; i &lt; NUM; i++)&#123; printf("%d\t",arr[i]); &#125;&#125; ##选择排序思想：记录较小数的下标min，当min不为初始值时交换。123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#define N 5void SelectSort(int arr[],int n)&#123; int i,j,min,tmp; for(i = 0;i &lt; n;i++)&#123; min = i; for(j = i + 1;j &lt; n;j++)&#123; if(arr[j] &lt; arr[min]) min = j; &#125; if(min != i)&#123; tmp = arr[min]; arr[min] = arr[i]; arr[i] = tmp; &#125; &#125;&#125;int main()&#123; int arr[N] = &#123;4,5,2,3,1&#125;; int i; SelectSort(arr,N); for(i = 0;i &lt; N;i++)&#123; printf("%d\t",arr[i]); &#125;&#125; 归并排序快速排序 思想：在一个无序序列中，把比主元(序列最左侧元素)大的元素放在主元右侧，不超过主元的放在左侧。 具体实现：12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int partition(int A[],int left,int right)&#123; int tmp=A[left]; while(left&lt;right)&#123; while(left&lt;right&amp;&amp;A[right]&gt;tmp) right--; A[left]=A[right];//找到时已跳出循环 while(left&lt;right&amp;&amp;A[left]&lt;=tmp) left++; A[right]=A[left]; &#125; A[left]=tmp; return left;&#125;void quickSort(int A[],int left,int right)&#123; if(left&lt;right)&#123;//易忽略的重要条件，区间长度要大于一。 int pos=partition(A,left,right); quickSort(A,left,pos-1);//左子区间 quickSort(A,pos+1,right);//右子区间 &#125; &#125;int main()&#123; return 0;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博的简陋记录]]></title>
    <url>%2F2018%2F08%2F25%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E7%9A%84%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[安装git如果是第一次使用，要先做如下操作： 配置git在命令行输入： $ git config --global user.email &quot;[you@example.com](mailto:you@example.com)&quot; $ git config --global user.name &quot;Your Name&quot; 利用 SSH 完成 Git 与 GitHub 的绑定： 详细教程 配置并绑定后方可通过git将本地内容推送到GitHub。 建gitpages官方教程（非常简单粗暴）最终呈现会是一个大大的helloWorld。 我的主页 安装hexo官方文档：( https://hexo.io/zh-cn/docs/ ) 新手安装hexo的坑：hexo init &lt;folder&gt;-&gt;hexo init x:\hexo 不要加&lt;&gt;(有特殊意义)，会报错bash: syntax error near unexpected token 部署hexo到github 与gitpages绑定： hexo文件夹下的_config.yml中设置deploy属性： 1234 deploy:type: gitrepo: git@github.com:0ltremar3/0ltremar3.github.io.gitbranch: master 基本命令： 1234hexo generate --生成个人博客所需的静态页面hexo server --本地预览hexo deploy --部署我们的个人博客hexo clean --清除缓存 写文章 12hexo new &quot;postName&quot; --新建文章hexo new page &quot;pageName&quot; --新建页面 生成的 .md文件在..:\hexo\source\_posts里,我用Typora编辑。 本地预览 123cd x://hexohexo ghexo s 浏览器打开http://localhost:4000即可预览。 部署到github 12hexo cleanhexo g -d]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
